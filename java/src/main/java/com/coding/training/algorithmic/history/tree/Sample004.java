package com.coding.training.algorithmic.history.tree;

/**
 * https://www.cnblogs.com/gaofei-1/p/7073393.html
 *
 * 给定一个二叉树，找出所有路径中各节点相加总和等于给定 目标值 的路径。
 *
 * 注意： 一个有效的路径，指的是从根节点到叶节点的路径。
 *
 * 给定一个二叉树，和 目标值 = 5:
 *
 *      1
 *     / \
 *    2   4
 *   / \
 *  2   3
 * 返回：
 *
 * [
 *   [1, 2, 2],
 *   [1, 4]
 * ]
 *
 * 分析：<1>一条路径都是从根节点出发到某一个叶子节点结束的，所以用二叉树的前序遍历（第一个访问根结点）；
 *      <2>需要把当前访问的结点保存到路径中，要计算累加值；
 *      <3>如果当前结点为叶子节点，但当前路径不符合输入数字 需要将当前结点从路径中清空  访问下一个结点；
 *      <4>如果当前结点是叶子结点 ，且路径上结点之和等于输入的数字，则输出此路径；
 *
 * 通过前序遍历，将访问的结点加入到路径中 并累加该结点的值；
 * 如果该结点是叶子结点 且路径上的累加值等于输入的数字 ，则当前路径符合要求 打印；
 * 如果该结点不是叶子结点，继续访问它的子节点；
 * 注意：当前结点为叶子节点 但是路径不符合要求是，要从路径中删除该节点 并从累加值中减去该结点的值 确保返回返回父节点时得到的路径刚好时从根节点到父节点的路径。。
 */


public class Sample004 {
    public static void main(String[] args) {

    }
}
