满足以下两个条件的树就是二叉树：
本身是有序树；
树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；

二叉树
    本身是有序树；
    树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2

二叉树具有以下几个性质：
    二叉树中，第 i 层最多有 2i-1 个结点。
    如果二叉树的深度为 K，那么此二叉树最多有 2K-1 个结点。
    二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1。


满二叉树：每个结点的度都为2
    满二叉树除了满足普通二叉树的性质，还具有以下性质：
    满二叉树中第 i 层的节点数为 2n-1 个。
    深度为 k 的满二叉树必有 2k-1 个节点 ，叶子数为 2k-1。
    满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。
    具有 n 个节点的满二叉树的深度为 log2(n+1)。

完全二叉树：最后一层的结点依次从左到右分布


二叉树的顺序存储，
    指的是使用顺序表（数组）存储二叉树。需要注意的是，顺序存储只适用于完全二叉树。换句话说，
    只有完全二叉树才可以使用顺序表存储。因此，如果我们想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树。

二叉树的遍历：
    深度优先遍历
        前序遍历：根节点->左子树->右子树（根->左->右）
        中序遍历：左子树->根节点->右子树（左->根->右）
        后序遍历：左子树->右子树->根节点（左->右->根）

        先序：拿到一个节点后，即刻输出该节点的值，并继续遍历其左右子树。(根左右)
        中序：拿到一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树。(左根右)
        后序：拿到一个节点后，将其暂存，遍历完左右子树后，再输出该节点的值。(左右根)
    广度优先遍历
        层次遍历
    满二叉树遍历结果
            前序遍历：1 2 4 5 3 6 7
            中序遍历：4 2 5 1 6 3 7
            后序遍历：4 5 2 6 7 3 1
            层次遍历：1 2 3 4 5 6 7
二叉树的存储结构
    链表
    顺序表

===============================================
二叉搜索树（Binary Sort Tree）
二叉搜索树，又称之为二叉排序树（二叉查找树），它或许是一棵空树，或许是具有以下性质的二叉树：

若他的左子树不为空，则左子树上所有节点的值都小于根节点的值
若它的右子树不为空，则右子树上所有节点的值都大于根节点的值
它的左右子树也分别是二叉搜索树

二叉搜索树的这种特性，使得我们在此二叉树上查找某个值就很方便了，从根节点开始，若要寻找的值小于根节点的值，
则在左子树上去找，反之则去右子树查找，知道找到与值相同的节点。插入节点也是一样的道理，从根节点出发，所要插入的值，
若小于根节点则去左子树寻找该节点所对应的位置，反之去右子树寻找，直到找到该节点合适的位置。

至于删除操作以及其他操作，相对比较麻烦，我会另写一篇二叉搜索树的详解，这里我们只了解二叉搜索树的基本性质即可。
===============================================
二叉平衡搜索树（AVL）
前面提到了二叉搜索树，我们知道，二叉搜索树的特性便于我们进行查找插入删除等一系列操作，
其时间复杂度为O（logn），但是，如果遇见最差的情况，比如以下这棵树：

这棵树，说是树，其实它已经退化成链表了，但从概念上来看，它仍是一棵二叉搜索树，只要我们按照逐次增大，
如1、2、3、4、5、6的顺序构造一棵二叉搜索树，则形如上图。那么插入的时间复杂度就变成了O(n)，
导致这种糟糕的情况原因是因为这棵树极其不平衡，右树的重量远大于左树，因此我们提出了叫平衡二叉搜索树的结构，
又称之为AVL树，是因为平衡二叉搜索树的发明者为Adel’son-Vel’skii 和Landis二人。
平衡二叉搜索树，它能保持二叉树的高度平衡，尽量降低二叉树的高度，减少树的平均查找长度。
AVL树的性质：

左子树与右子树高度之差的绝对值不超过1
树的每个左子树和右子树都是AVL树
每一个节点都有一个平衡因子（balance factor），任一节点的平衡因子是-1、0、1（每一个节点的平衡因子 = 右子树高度 - 左子树高度）
做到了这点，这棵树看起来就比较平衡了，那么如何生成一棵AVL树呢?算法相对来说复杂，随着新节点的加入，树自动调整自身结构，达到新的平
衡状态，这就是我们想要的AVL树。我们先要分析，为什么树会失衡?是由于插入了一个新的元素

=======================================


数据结构中为了存储和查找的方便，用各种树结构来存储数据，下面就浅谈一下各种树的表示方法、特点及各自的用途，涉及的树结构包括：二叉搜索树（二叉查找树,二叉排序树）、平衡二叉树（AVL树）、红黑树、B-树、B+树、字典树（trie树）、后缀树、广义后缀树。

① 二叉搜索树（二叉查找树,二叉排序树）
二叉查找树是一种动态查找表，具有这些性质：
（1）若它的左子树不为空，则左子树上的所有节点的值都小于它的根节点的值；
（2）若它的右子树不为空，则右子树上所有节点的值都大于它的根节点的值；
（3）其他的左右子树也分别为二叉查找树；
（4）二叉查找树是动态查找表，在查找的过程中可见添加和删除相应的元素，在这些操作中需要保持二叉查找树的以上性质。

② 平衡二叉树（AVL树）
含有相同节点的二叉查找树可以有不同的形态，而二叉查找树的平均查找长度与树的深度有关，所以需要找出一个查找平均长度最小的一棵，那就是平衡二叉树，具有以下性质：
（1）要么是棵空树，要么其根节点左右子树的深度之差的绝对值不超过1；
（2）其左右子树也都是平衡二叉树；
（3）二叉树节点的平衡因子定义为该节点的左子树的深度减去右子树的深度。则平衡二叉树的所有节点的平衡因子只可能是-1,0,1。

③ 红黑树
红黑树是一种自平衡二叉树，在平衡二叉树的基础上每个节点又增加了一个颜色的属性，节点的颜色只能是红色或黑色。具有以下性质：
（1）根节点只能是黑色；
（2）红黑树中所有的叶子节点后面再接上左右两个空节点，这样可以保持算法的一致性，而且所有的空节点都是黑色；
（3）其他的节点要么是红色，要么是黑色，红色节点的父节点和左右孩子节点都是黑色，及黑红相间；
（4）在任何一棵子树中，从根节点向下走到空节点的路径上所经过的黑节点的数目相同，从而保证了是一个平衡二叉树。

④ B-树
B-树是一种平衡多路查找树，它在文件系统中很有用。一棵m阶B-树，具有下列性质：
（1）树中每个节点至多有m棵子树；
（2）若根节点不是叶子节点，则至少有2棵子树；
（3）除根节点之外的所有非终端节点至少有棵子树；
（4）每个节点中的信息结构为（A0,K1,A1,K2……Kn,An），其中n表示关键字个数，Ki为关键字，Ai为指针；
（5）所有的叶子节点都出现在同一层次上，且不带任何信息，也是为了保持算法的一致性。

⑤ B+树
B+数是B-树的一种变形，它与B-树的差别在于：
（1）有n棵子树的节点含有n个关键字；
（2）所有的叶子节点包含了全部关键字的信息，及指向这些关键字记录的指针，且叶子节点本身按关键字大小自小到大顺序链接；
（3）所有非终端节点可以看成是索引部分，节点中仅含有其子树（根节点）中最大（或最小）关键字，所有B+树更像一个索引顺序表；
（4）对B+树进行查找运算，一是从最小关键字起进行顺序查找，二是从根节点开始，进行随机查找。

⑥ 字典树（trie树）
字典树是一种以树形结构保存大量字符串。以便于字符串的统计和查找，经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来节约存储空间，最大限度地减少无谓的字符串比较，查询效率比哈希表高。具有以下特点：
（1）根节点为空；
（2）除根节点外，每个节点包含一个字符；
（3）从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。
（4）每个字符串在建立字典树的过程中都要加上一个区分的结束符，避免某个短字符串正好是某个长字符串的前缀而淹没。

⑦ 后缀树
后缀树则是一个字符串的所有后缀组成的字典树。

⑧ 广义后缀树
广义后缀树是好几个字符串的的所有后缀组成的字典树，同样每个字符串的所有后缀都具有一个相同的结束符，不同字符串的结束符不同。




