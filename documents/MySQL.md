#数据库
>1.事务四大特性（ACID)？
* 原子性:是指事务包含的所有操作要么全部成功，要么全部失败回滚.
* 一致性:用户A和用户B两者的钱加起来一共是100，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是100
* 隔离性:多个用户并发访问DB，DB为每个用户开启的事务之间要相互隔离
* 持久性:数据库系统遇到故障的情况下也不会丢失提交事务的操作。

>2.并发执行事务存在哪些问题？
* 脏读：B事务读取到了A事务尚未提交的数据
* 不可重复读：一个事务中两次读取的数据的内容不一致
* 幻读/虚读：一个事务中两次读取的数据的数量不一致
	
>3.数据库隔离级别，每个级别会引发什么问题，mysql默认是哪个级别？
* read uncommitted : 读未提交 ：哪个问题都不能解决
* read committed：读已提交 ：解决脏读 —- oracle默认的
* repeatable read：可重复读：解决脏读和不可重复读 —mysql默认的
* serializable：串行化：解决所有问题—相当于锁表

>4.innodb和myisam存储引擎的区別？
* MyIASM是非事务安全的，而InnoDB是事务安全的
* MyIASM锁的粒度是表级的，而InnoDB支持行级锁
* MyIASM支持全文类型索引，而InnoDB不支持全文索引
* MyIASM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyIASM
* MyIASM表保存成文件形式，跨平台使用更加方便

>5.innodb和myisam存储引擎各自的适用场景？
* MyIASM管理非事务表，提供高速存储和全文搜索能力，如果再应用中执行大量select操作，应该选择MyIASM
* InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，应该选择InnoDB

>6.查询语句不同元素（where、join、limit, group by、having等等）执行先后顺序？
* 执行顺序 ：from >  on > join > where > group by > having > select > DISTINCT > order by > TOP

>7.索引原理
* B+树

>8.查询优化
* 创建索引原则
    * 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
    * =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。
    * 尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。
    * 索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。
    * 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。
* 执行计划(explain) 
    * 这里需要强调rows是核心指标，绝大部分rows小的语句执行一定很快（有例外，下面会讲到）。所以优化语句基本上都是在优化rows。
* 优化步骤
    * 先运行看看是否真的很慢，注意设置SQL_NO_CACHE
    * where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高
    * explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）
    * order by limit 形式的sql语句让排序的表优先查
    * 了解业务方使用场景
    * 加索引时参照建索引的几大原则
    * 观察结果，不符合预期继续从0分析
    * 小结果表作为驱动表
* 优化示例
    * where 条件锁定的记录很少300左右，但是explain “rows比较大” 减少rows
    * 列区分度底，性别，只能跟业务商量
    * order by limit
    
>9.mysql的Index Nested-Loop Join和Block Nested-Loop Join机制(嵌套循环链接机制)
* 在Mysql的实现中，Nested-Loop Join有3种实现的算法：
    * Simple Nested-Loop Join：SNLJ，简单嵌套循环连接
    * Index Nested-Loop Join：INLJ，索引嵌套循环连接
    * Block Nested-Loop Join：BNLJ，缓存块嵌套循环连接
    * 优先级从高到低 Index Nested-LoopJoin > Block Nested-Loop Join > Simple Nested-Loop Join
* Simple Nested-Loop Join
    * 简单嵌套循环连接实际上就是简单粗暴的嵌套循环，如果table1有1万条数据，table2有1万条数据，那么数据比较的次数=1万 * 1万 =1亿次，这种查询效率会非常慢。
    * 所以Mysql继续优化，然后衍生出Index Nested-LoopJoin、Block Nested-Loop Join两种NLJ算法。在执行join查询时mysql会根据情况选择两种之一进行join查询。
* Index Nested-Loop Join（减少内层表数据的匹配次数）
    * 索引嵌套循环连接是基于索引进行连接的算法，索引是基于内层表的，通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表的每条记录进行比较， 从而利用索引的查询减少了对内层表的匹配次数，优势极大的提升了 join的性能：
        * 原来的匹配次数 = 外层表行数 * 内层表行数
        * 优化后的匹配次数= 外层表的行数 * 内层表索引的高度
    * 使用场景：只有内层表join的列有索引时，才能用到Index Nested-LoopJoin进行连接。
    * 由于用到索引，如果索引是辅助索引而且返回的数据还包括内层表的其他数据，则会回内层表查询数据，多了一些IO操作。
* Block Nested-Loop Join（减少内层表数据的循环次数）
    * 缓存块嵌套循环连接通过一次性缓存多条数据，把参与查询的列缓存到Join Buffer 里，然后拿join buffer里的数据批量与内层表的数据进行匹配，从而减少了内层循环的次数（遍历一次内层表就可以批量匹配一次Join Buffer里面的外层表数据）。
    * 当不使用Index Nested-Loop Join的时候，默认使用Block Nested-Loop Join。
    * 什么是Join Buffer？
        * Join Buffer会缓存所有参与查询的列而不是只有Join的列。
        * 可以通过调整join_buffer_size缓存大小
        * join_buffer_size的默认值是256K，join_buffer_size的最大值在MySQL 5.1.22版本前是4G-1，而之后的版本才能在64位操作系统下申请大于4G的Join Buffer空间。
        * 使用Block Nested-Loop Join算法需要开启优化器管理配置的optimizer_switch的设置block_nested_loop为on，默认为开启。
          
>10.如何优化Join速度
* 用小结果集驱动大结果集，减少外层循环的数据量：如果小结果集和大结果集连接的列都是索引列，mysql在内连接时也会选择用小结果集驱动大结果集，因为索引查询的成本是比较固定的，这时候外层的循环越少，join的速度便越快。
* 为匹配的条件增加索引：争取使用INLJ，减少内层表的循环次数
* 增大join buffer size的大小：当使用BNLJ时，一次缓存的数据越多，那么外层表循环的次数就越少
* 减少不必要的字段查询：
        * 当用到BNLJ时，字段越少，join buffer 所缓存的数据就越多，外层表的循环次数就越少；
        * 当用到INLJ时，如果可以不回表查询，即利用到覆盖索引，则可能可以提示速度。（未经验证，只是一个推论）
    
>11.索引有B+索引和hash索引，各自的区别？
* 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；
    * 当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，
    * 然后再根据链表往后扫描，直到找到相应的数据；
* 从示意图中也能看到，如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，
    * 经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；
* 同理，哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；
* 哈希索引也不支持多列联合索引的最左匹配规则；
* B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，
    * 哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。
    
>12.聚集索引和非聚集索引区别
* 两者的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。
	* 聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个。
	* 聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续。
	* 聚集索引查询数据速度快，插入数据速度慢；非聚集索引反之。

>13.有哪些锁（乐观锁悲观锁），select时怎么加排它锁？
* 用法： select … for update;
* 例如：select * from goods where id = 1 for update;
* 排他锁的申请前提：没有线程对该结果集中的任何行数据使用排他锁或共享锁，否则申请会阻塞。
* for update仅适用于InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效。
    
>14.MySQL 锁级别有哪些，区别是什么?
* 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。
* 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。
* 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般
    
>15.死锁判定原理和具体场景，死锁怎么解决？
* mysql 有一个 wait-for graph算法, 两个事物相互等待对方释放锁时，就形成了一个环，有环就有死锁
* 具体场景：jobA处理的的id列表为[1,2,3,4]，而job处理的id列表为[8,9,10,4,2]，这样就造成了死锁。
* 解决办法是 设置 lock_wait_timeout 参数  
    
>16.DB如何避免死锁?
* 以固定的顺序访问表和行。比如对第2节两个job批量更新的情形，简单方法是对id列表先排序，后执行，这样就避免了交叉等待锁的情形；又比如对于3.1节的情形，将两个事务的sql顺序调整为一致，也能避免死锁。
* 大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。
* 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。
* 降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。
* 为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。

>17.varchar和char的使用场景？  
* varchar：存放不定长的数据，比如文章
* char：是定长的，插入数据不足规定长度的，右边补空格
* char：存放定长的数据，比如身份证号和手机号
    
>18.mysql并发情况下怎么解决？
* 通过事务、隔离级别、锁

>19.为啥用树形结构来存储?
* 查询效率很高,可以在 O(logn) 的时间复杂度查找到目标数据。

>20.]为啥DB文件索引要用B树而不用二叉查找树？
* 如果是查找效率（即比较次数）的话，实际上二叉树可以说是最快的了，但是，我们的文件索引是存放在磁盘上的，所以我们不仅要考虑查找效率，还要考虑磁盘的寻址加载次数哦，而这也是我们为什么要用 B 树的原因。
  
>21.为什么二叉查找树会导致磁盘的加载次数更多？  
* 数据不是连续的，二叉树孩子少于B树，因此比较的次数比B树多，磁盘访问次数增多
* 再把磁盘里的数据加载到内存中的时候，是以页为单位来加载的，而我们也知道，节点与节点之间的数据是不连续的，所以不同的节点，很有可能分布在不同的磁盘页中
* 实际上磁盘的加载次数，基本上是和树的高度相关联的，高度越高，加载次数越多，越矮，加载次数越少。所以对于这种文件索引的存储，我们一般会选择矮胖的树形结构。
    
    
    
    
    
    
    
    
    
    
    
    
    