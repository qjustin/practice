package com.coding.training.algorithmic.dp;

/**
 * 给定一个无序的整数数组，找到其中最长上升子序列的长度。
 * <p>
 * 示例:
 * <p>
 * 输入: [10,9,2,5,3,7,101,18]
 * 输出: 4
 * 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
 * 说明:
 * <p>
 * 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
 * 你算法的时间复杂度应该为 O(n2) 。
 * 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?
 * <p>
 * 思路
 * dp[i]表示以nums[i]为结尾的最长上升子序列的长度，
 * 如果nums[j] < nums[i]并且dp[j]+1>dp[i],
 * 即把nums[i]跟在以nums[j]为结尾的序列后面，则dp[i]=dp[j]+1
 * <p>
 * 由于这个最长上升序列不一定是连续的，对于每一个新加入的数，
 * 都有可能跟前面的序列构成一个较长的上升序列，或者跟后面的序列构成一个较长的上升序列。
 * 比如1,3,5,2,8,4,6，对于6来说，可以构成1,3,5,6，也可以构成2,4,6。
 * 因为前面那个序列长为4，后面的长为3，所以我们更愿意6组成那个长为4的序列，
 * 所以对于6来说，它组成序列的长度，实际上是之前最长一个升序序列长度加1，
 * 注意这个最长的序列的末尾是要小于6的，不然我们就把1,3,5,8,6这样的序列给算进来了。
 * 这样，我们的递推关系就隐约出来了，假设dp[i]代表加入第i个数能构成的最长升序序列长度，
 * 我们就是要在dp[0]到dp[i-1]中找到一个最长的升序序列长度，又保证序列尾值nums[j]小于nums[i]，
 * 然后把这个长度加上1就行了。同时，我们还要及时更新最大长度。
 */
public class Sample009 {
    public int lengthOfLIS(int[] nums) {
        int max = 0;
        int[] dp = new int[nums.length];//以第i个位置为结尾的序列长度
        for (int i = 0; i < nums.length; i++) {
            dp[i] = 1;
            for (int j = 0; j < i; ++j) {
                if (dp[j] + 1 > dp[i] && nums[j] < nums[i]) {
                    dp[i] = dp[j] + 1;
                }
            }
            if (dp[i] > max) {
                max = dp[i];
            }
        }

        return max;
    }
}
